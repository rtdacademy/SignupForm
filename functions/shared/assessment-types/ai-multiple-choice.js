/**
 * Reusable AI Multiple Choice Assessment Module
 * This module provides a factory function to create AI-powered multiple choice assessments
 * Course developers can import this and configure it with their specific prompts and settings
 * 
 * ARCHITECTURE:
 * =============
 * This backend module works in conjunction with the frontend component:
 * - Frontend: src/FirebaseCourses/components/assessments/AIMultipleChoiceQuestion/index.js
 * - Backend: This module creates cloud functions that the frontend calls
 * - Configuration: Set parameters in course-specific files like functions/courses/2/02-momentum-one-dimension/assessments.js
 * 
 * The frontend component automatically handles:
 * - Displaying questions generated by this module
 * - Student answer submission and evaluation
 * - AI chat integration (if enabled)
 * - Progress tracking and attempt management
 * - Theme and UI customization based on your configuration
 * 
 * WORKFLOW:
 * =========
 * 1. Configure this module in your course assessment file (functions/courses/[courseId]/[content]/assessments.js)
 * 2. Deploy the cloud function
 * 3. Frontend component calls your cloud function to generate/evaluate questions
 * 4. Students interact with questions through the frontend UI
 * 5. All configuration (prompts, AI chat, themes, etc.) is controlled server-side for security
 * 
 * USAGE:
 * ======
 * 
 * To use this module in your course assessment file:
 * 
 * ```javascript
 * const { createAIMultipleChoice } = require('../../../shared/assessment-types/ai-multiple-choice');
 * 
 * exports.yourFunctionName = createAIMultipleChoice({
 *   // Configuration object - see ACCEPTED PARAMETERS below
 * });
 * ```
 * 
 * ACCEPTED PARAMETERS:
 * ===================
 * 
 * Core Configuration:
 * - prompts: {Object} - Prompts for different difficulty levels
 *   - beginner: {string} - Prompt for beginner-level questions
 *   - intermediate: {string} - Prompt for intermediate-level questions  
 *   - advanced: {string} - Prompt for advanced-level questions
 * 
 * Activity Settings:
 * - activityType: {string} - Type of activity ('lesson', 'assignment', 'exam', 'lab')
 * - maxAttempts: {number} - Maximum attempts allowed (default: from course config)
 * - pointsValue: {number} - Points awarded for correct answer (default: 2)
 * - showFeedback: {boolean} - Whether to show detailed feedback (default: true)
 * - enableHints: {boolean} - Whether to enable hints (default: true)
 * - attemptPenalty: {number} - Points deducted per attempt (default: 0)
 * - theme: {string} - Color theme ('blue', 'green', 'purple', 'amber')
 * - allowDifficultySelection: {boolean} - Allow students to select difficulty (default: false)
 * - defaultDifficulty: {string} - Default difficulty level ('beginner', 'intermediate', 'advanced')
 * - freeRegenerationOnDifficultyChange: {boolean} - Don't count difficulty changes as attempts
 * 
 * AI Chat Settings:
 * - enableAIChat: {boolean} - Whether to show AI chat button for students (default: undefined, shows by default)
 * - aiChatContext: {string} - Additional context about the question to help AI tutors provide better assistance
 * 
 * AI Generation Settings:
 * - aiSettings: {Object} - AI generation parameters
 *   - temperature: {number} - AI creativity (0-1, default: 0.7)
 *   - topP: {number} - Nucleus sampling (0-1, default: 0.8)
 *   - topK: {number} - Top-K sampling (default: 40)
 * 
 * Content Settings:
 * - katexFormatting: {boolean} - Enable LaTeX math formatting (default: false)
 * - subject: {string} - Subject name for context
 * - gradeLevel: {number} - Grade level for context
 * - topic: {string} - Topic name for context
 * - learningObjectives: {Array<string>} - Learning objectives for context
 * 
 * Fallback Questions:
 * - fallbackQuestions: {Array<Object>} - Backup questions if AI generation fails
 *   Each fallback question should have:
 *   - questionText: {string}
 *   - options: {Array<Object>} - Array of {id, text} objects
 *   - correctOptionId: {string} - ID of correct option ('a', 'b', 'c', or 'd')
 *   - explanation: {string} - Explanation of the correct answer
 *   - difficulty: {string} - Difficulty level
 * 
 * Cloud Function Settings:
 * - region: {string} - Firebase function region (default: 'us-central1')
 * - timeout: {number} - Function timeout in seconds (default: 60)
 * - memory: {string} - Memory allocation (default: '512MiB')
 * 
 * EXAMPLE USAGE:
 * ==============
 * 
 * ```javascript
 * exports.course2_momentum_aiQuestion = createAIMultipleChoice({
 *   prompts: {
 *     beginner: "Create a basic momentum question for Grade 12 students...",
 *     intermediate: "Create an intermediate momentum question...",
 *     advanced: "Create an advanced momentum problem..."
 *   },
 *   activityType: 'lesson',
 *   enableAIChat: true,
 *   aiChatContext: "This question tests momentum conservation. Students often struggle with vector components and collision types.",
 *   katexFormatting: true,
 *   maxAttempts: 5,
 *   pointsValue: 2,
 *   theme: 'purple',
 *   subject: 'Physics 30',
 *   gradeLevel: 12,
 *   topic: 'Momentum',
 *   fallbackQuestions: [
 *     {
 *       questionText: "A 2000 kg car traveling at 15 m/s has what momentum?",
 *       options: [
 *         { id: 'a', text: '30,000 kgÂ·m/s' },
 *         { id: 'b', text: '15,000 kgÂ·m/s' },
 *         { id: 'c', text: '2,000 kgÂ·m/s' },
 *         { id: 'd', text: '7.5 kgÂ·m/s' }
 *       ],
 *       correctOptionId: 'a',
 *       explanation: 'Momentum = mass Ã— velocity = 2000 kg Ã— 15 m/s = 30,000 kgÂ·m/s',
 *       difficulty: 'beginner'
 *     }
 *   ]
 * });
 * ```
 */

const { onCall } = require('firebase-functions/v2/https');
const { genkit } = require('genkit/beta');
const { googleAI } = require('@genkit-ai/googleai');
const { z } = require('zod');
const { loadConfig } = require('../utilities/config-loader');
const { extractParameters, initializeCourseIfNeeded, getServerTimestamp, getDatabaseRef } = require('../utilities/database-utils');
const { storeSubmission, createMultipleChoiceSubmissionRecord } = require('../utilities/submission-storage');
const { AIQuestionSchema } = require('../schemas/assessment-schemas');
const { applyPromptModules } = require('../prompt-modules');

// Environment variables
const GEMINI_API_KEY = process.env.GEMINI_API_KEY;

// Function to initialize AI with API key
function initializeAI(apiKey) {
  return genkit({
    plugins: [googleAI({ apiKey })],
    model: googleAI.model('gemini-2.0-flash'),
  });
}

/**
 * Shuffles an array in place
 * @param {Array} array - The array to shuffle
 * @returns {Array} The shuffled array
 */
function shuffleArray(array) {
  for (let i = array.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [array[i], array[j]] = [array[j], array[i]];
  }
  return array;
}

/**
 * Uses Genkit with structured outputs to generate a custom multiple choice question
 * @param {Object} config - Configuration object with prompts and settings
 * @param {string} topic - The question topic
 * @param {string} difficulty - The difficulty level (beginner, intermediate, advanced)
 * @param {Array} fallbackQuestions - Course-specific fallback questions
 * @returns {Promise<Object>} Generated question with options and solution
 */
async function generateAIQuestion(config, topic, difficulty = 'intermediate', fallbackQuestions = []) {
  try {
    // Check if API key is available
    if (!GEMINI_API_KEY) {
      console.warn("No Gemini API key found. Using fallback question instead.");
      return getFallbackQuestion(difficulty, fallbackQuestions);
    }

    // Get the appropriate prompt template from config
    const prompts = config.prompts || {};
    const promptTemplate = prompts[difficulty] || prompts.intermediate || 
      `Create a multiple-choice question about ${topic} at ${difficulty} level.`;
    
    // Apply conditional prompt modules as system instructions
    const systemInstructions = applyPromptModules(config);
    
    // Create clean prompt content focused on the task
    const promptText = `${promptTemplate}

    REQUIREMENTS:
    1. Create a question that tests understanding, not just memorization
    2. Make sure the question has ONE clear correct answer
    3. Ensure all incorrect options (distractors) are plausible but clearly wrong
    4. Include specific feedback for each answer option explaining why it's correct or incorrect
    5. Use exactly 4 options with IDs: a, b, c, and d`;
    
    console.log("Generating AI question with structured output using Genkit");
    
    try {
      // Use Genkit's structured output with our Zod schema
      const generateOptions = {
        model: googleAI.model('gemini-2.0-flash'),
        prompt: promptText,
        output: { 
          schema: AIQuestionSchema
        },
        config: {
          temperature: config.aiSettings?.temperature || 0.7,
          topP: config.aiSettings?.topP || 0.8,
          topK: config.aiSettings?.topK || 40
        }
      };
      
      // Add system instructions if we have prompt modules enabled
      if (systemInstructions && systemInstructions.trim().length > 0) {
        generateOptions.system = systemInstructions;
      }
      
      const { output } = await ai.generate(generateOptions);
      
      if (output == null) {
        console.error("Genkit returned null output for AI question generation");
        throw new Error("Response doesn't satisfy schema.");
      }
      
      // Validate required fields are present and properly formatted
      if (!output.questionText || typeof output.questionText !== 'string' || output.questionText.trim().length === 0) {
        console.error("Invalid or missing questionText:", output.questionText);
        throw new Error("Generated question is missing valid questionText");
      }
      
      if (!output.options || !Array.isArray(output.options) || output.options.length !== 4) {
        console.error("Invalid options array:", output.options);
        throw new Error("Generated question must have exactly 4 options");
      }
      
      if (!output.correctOptionId || !['a', 'b', 'c', 'd'].includes(output.correctOptionId)) {
        console.error("Invalid correctOptionId:", output.correctOptionId);
        throw new Error("Generated question has invalid correctOptionId");
      }
      
      if (!output.explanation || typeof output.explanation !== 'string' || output.explanation.trim().length === 0) {
        console.error("Invalid or missing explanation:", output.explanation);
        throw new Error("Generated question is missing valid explanation");
      }
      
      // Validate that explanation doesn't contain excessive whitespace or malformed content
      // Increased limit to 5000 characters to accommodate detailed physics explanations
      if (output.explanation.length > 5000) {
        console.error("Explanation is too long (>5000 chars):", output.explanation.substring(0, 100) + "...");
        throw new Error("Generated explanation is too long");
      }
      
      // Check for truly malformed content (e.g., repeated characters, empty explanation)
      if (output.explanation.match(/(.)\1{50,}/) || output.explanation.replace(/\s/g, '').length < 10) {
        console.error("Explanation appears malformed:", output.explanation.substring(0, 100));
        throw new Error("Generated explanation appears malformed");
      }
      
      console.log("Successfully generated AI question with structured output:", 
        output.questionText.substring(0, 50) + "...");
      
      return {
        ...output,
        generatedBy: 'ai'
      };
      
    } catch (err) {
      console.error("Error with Genkit AI generation:", err.message);
      console.log("Falling back to predefined question due to AI generation error");
      return getFallbackQuestion(difficulty, fallbackQuestions);
    }
  } catch (error) {
    console.error("Error generating AI question:", error);
    return getFallbackQuestion(difficulty, fallbackQuestions);
  }
}

/**
 * Gets a fallback question from course-specific fallbacks or defaults
 * @param {string} difficulty - The difficulty level
 * @param {Array} fallbackQuestions - Course-specific fallback questions
 * @returns {Object} A fallback question
 */
function getFallbackQuestion(difficulty = 'intermediate', fallbackQuestions = []) {
  // First try course-specific fallbacks
  const filteredFallbacks = fallbackQuestions.filter(q => q.difficulty === difficulty);
  const availableFallbacks = filteredFallbacks.length > 0 ? filteredFallbacks : 
    fallbackQuestions.filter(q => q.difficulty === 'intermediate');
  
  if (availableFallbacks.length > 0) {
    const randomIndex = Math.floor(Math.random() * availableFallbacks.length);
    const selectedQuestion = availableFallbacks[randomIndex];
    
    // Shuffle the options for variety
    const shuffledOptions = shuffleArray([...selectedQuestion.options]);
    
    return {
      questionText: selectedQuestion.questionText,
      options: shuffledOptions,
      correctOptionId: selectedQuestion.correctOptionId,
      explanation: selectedQuestion.explanation,
      generatedBy: 'fallback'
    };
  }
  
  // If no fallbacks available, return a generic question
  return {
    questionText: "This is a placeholder question that should be replaced with course-specific content.",
    options: [
      { id: "a", text: "Option A", feedback: "Please add course-specific fallback questions." },
      { id: "b", text: "Option B", feedback: "Please add course-specific fallback questions." },
      { id: "c", text: "Option C", feedback: "Correct placeholder answer." },
      { id: "d", text: "Option D", feedback: "Please add course-specific fallback questions." }
    ],
    correctOptionId: "c",
    explanation: "This is a placeholder question. Course developers should provide fallback questions.",
    generatedBy: 'placeholder'
  };
}

/**
 * Evaluates the student's answer to the AI-generated question
 * @param {Object} question - The question object with correctOptionId and options
 * @param {string} studentAnswer - The student's selected option ID
 * @returns {Object} Result of the evaluation
 */
function evaluateAIQuestionAnswer(question, studentAnswer) {
  // Check if the selected answer is one of the valid options
  if (!question.options.some(opt => opt.id === studentAnswer)) {
    return {
      isCorrect: false,
      correctOptionId: question.correctOptionId,
      feedback: "Invalid answer selection",
      explanation: question.explanation
    };
  }

  const isCorrect = studentAnswer === question.correctOptionId;
  
  // Get the appropriate feedback based on selected option
  const selectedOption = question.options.find(opt => opt.id === studentAnswer);
  const feedback = selectedOption ? selectedOption.feedback : "";
  
  return {
    isCorrect,
    correctOptionId: question.correctOptionId,
    feedback: feedback || (isCorrect ? "Correct!" : "Incorrect."),
    explanation: question.explanation
  };
}

/**
 * Infers activity type from assessment ID patterns
 * @param {string} assessmentId - The assessment identifier
 * @returns {string} The inferred activity type
 */
function inferActivityTypeFromAssessmentId(assessmentId) {
  if (!assessmentId) return 'lesson';
  
  const id = assessmentId.toLowerCase();
  
  if (id.includes('assignment') || id.includes('homework') || id.includes('hw')) {
    return 'assignment';
  } else if (id.includes('exam') || id.includes('test') || id.includes('final')) {
    return 'exam';
  } else if (id.includes('lab') || id.includes('laboratory') || id.includes('experiment')) {
    return 'lab';
  } else {
    return 'lesson';
  }
}

/**
 * Core business logic for AI Multiple Choice assessments
 * This can be called directly by other systems without Firebase wrapper
 */
class AIMultipleChoiceCore {
  constructor(config = {}) {
    this.config = config;
  }

  async handleGenerate(params) {
    const { courseConfig } = this;
    
    // Load and merge configurations
    const globalConfig = await loadConfig();
    
    // SECURITY: Use hardcoded activity type from course config (cannot be manipulated by client)
    // Priority: courseConfig.activityType (hardcoded) > inferred from assessmentId > fallback to lesson
    const activityType = this.config.activityType || inferActivityTypeFromAssessmentId(params.assessmentId) || 'lesson';
    
    // Log the activity type being used for debugging
    console.log(`Using activity type: ${activityType} (Source: ${this.config.activityType ? 'hardcoded' : 'inferred'})`);
    
    // Get activity-specific configuration
    const activityConfig = this.config.activityTypes?.[activityType] || this.config.activityTypes?.lesson || {};
    
    const config = {
      ...globalConfig.questionTypes?.multipleChoice?.ai_generated || {},
      ...activityConfig,
      ...this.config
    };

    // Initialize course if needed
    await initializeCourseIfNeeded(params.studentKey, params.courseId, params.isStaff);

    // Reference to the assessment in the database
    const assessmentRef = getDatabaseRef('studentAssessment', params.studentKey, params.courseId, params.assessmentId, params.isStaff);
    const dbPath = params.isStaff 
      ? `staff_testing/${params.studentKey}/courses/${params.courseId}/Assessments/${params.assessmentId}`
      : `students/${params.studentKey}/courses/${params.courseId}/Assessments/${params.assessmentId}`;
    console.log(`Database path: ${dbPath}`);

    // Check if this is a regeneration or a new assessment
    const existingAssessmentSnapshot = await assessmentRef.once('value');
    const existingAssessment = existingAssessmentSnapshot.val();
    const isRegeneration = !!existingAssessment;
    
    // Initialize the attempts counter
    let currentAttempts = 0;
    if (existingAssessment) {
      currentAttempts = existingAssessment.attempts || 0;
    }
    
    console.log(`This is a ${isRegeneration ? 'regeneration' : 'new question'} request. Current attempts: ${currentAttempts}`);
    
    // Look up course settings to get max attempts
    const courseRef = getDatabaseRef('courseAssessment', params.courseId, params.assessmentId);
    const courseAssessmentSnapshot = await courseRef.once('value');
    const courseAssessmentData = courseAssessmentSnapshot.val();
    
    // Determine max attempts from hierarchy: courseConfig > activityConfig > courseAssessmentData > defaults
    let maxAttempts = config.maxAttempts || activityConfig.maxAttempts || 9999;
    if (courseAssessmentData && courseAssessmentData.maxAttempts) {
      maxAttempts = courseAssessmentData.maxAttempts;
    }
    
    console.log(`Max attempts configuration: courseConfig=${config.maxAttempts}, activityConfig=${activityConfig.maxAttempts}, final=${maxAttempts}`);
    
    console.log(`Max attempts allowed: ${maxAttempts}`);
    
    // Verify the student hasn't exceeded the max attempts
    if (isRegeneration && currentAttempts >= maxAttempts) {
      console.log(`Security check: Student has exceeded max attempts (${currentAttempts}/${maxAttempts})`);
      throw new Error(`Maximum attempts (${maxAttempts}) reached for this assessment. No more regenerations allowed.`);
    }
    
    // Generate the AI question using course-specific config
    console.log(`Generating AI question on topic: ${params.topic}, difficulty: ${params.difficulty}`);
    const question = await generateAIQuestion(
      config,
      params.topic,
      params.difficulty,
      this.config.fallbackQuestions || []
    );
    
    // Prepare the question data
    const randomizedOptions = shuffleArray([...question.options]);
    
    // Create the final question data object to save
    const questionData = {
      timestamp: getServerTimestamp(),
      questionText: question.questionText,
      options: randomizedOptions.map(opt => ({ id: opt.id, text: opt.text })),
      topic: params.topic,
      difficulty: params.difficulty,
      generatedBy: question.generatedBy || 'ai',
      attempts: currentAttempts,
      status: 'active',
      maxAttempts: maxAttempts,
      activityType: activityType,
      pointsValue: config.pointsValue || activityConfig.pointValue || 2,
      attemptPenalty: config.attemptPenalty || activityConfig.attemptPenalty || 0,
      settings: {
        showFeedback: config.showFeedback !== false && activityConfig.showDetailedFeedback !== false,
        enableHints: config.enableHints !== false && activityConfig.enableHints !== false,
        allowDifficultySelection: config.allowDifficultySelection || activityConfig.allowDifficultySelection || false,
        theme: config.theme || activityConfig.theme || 'purple',
        defaultDifficulty: config.defaultDifficulty || activityConfig.defaultDifficulty || 'intermediate',
        freeRegenerationOnDifficultyChange: config.freeRegenerationOnDifficultyChange || activityConfig.freeRegenerationOnDifficultyChange || false
      }
    };
    
    // Only add optional properties if they are defined
    if (config.enableAIChat !== undefined) {
      questionData.enableAIChat = config.enableAIChat;
    }
    if (config.aiChatContext !== undefined) {
      questionData.aiChatContext = config.aiChatContext;
    }
    
    // Store public question data in the database (student-accessible)
    await assessmentRef.set(questionData);

    // Store the secure data in a completely separate database node (server-side only)
    const secureRef = getDatabaseRef('secureAssessment', params.courseId, params.assessmentId, params.studentKey);
    
    await secureRef.set({
      correctOptionId: question.correctOptionId,
      explanation: question.explanation,
      // Store option feedback for each ID
      optionFeedback: question.options.reduce((obj, opt) => {
        obj[opt.id] = opt.feedback || "";
        return obj;
      }, {}),
      timestamp: getServerTimestamp()
    });

    return {
      success: true,
      questionGenerated: true,
      assessmentId: params.assessmentId,
      generatedBy: question.generatedBy
    };
  }

  async handleEvaluate(params) {
    // Initialize course if needed
    await initializeCourseIfNeeded(params.studentKey, params.courseId, params.isStaff);

    // Reference to the assessment in the database
    const assessmentRef = getDatabaseRef('studentAssessment', params.studentKey, params.courseId, params.assessmentId, params.isStaff);
    
    // Get the existing question data
    const assessmentSnapshot = await assessmentRef.once('value');
    const assessmentData = assessmentSnapshot.val();

    if (!assessmentData) {
      throw new Error('Assessment not found');
    }
    
    // Verify max attempts from course settings
    const courseRef = getDatabaseRef('courseAssessment', params.courseId, params.assessmentId);
    const courseAssessmentSnapshot = await courseRef.once('value');
    const courseAssessmentData = courseAssessmentSnapshot.val();
    
    // Use course-specific max attempts if available, otherwise use assessment value
    const maxAttemptsFromSettings = (courseAssessmentData && courseAssessmentData.maxAttempts) ? 
      courseAssessmentData.maxAttempts : assessmentData.maxAttempts;
      
    // Security check: Always use the smaller value between saved assessment maxAttempts and 
    // course settings maxAttempts to prevent manipulation
    const secureMaxAttempts = Math.min(
      assessmentData.maxAttempts || 9999,
      maxAttemptsFromSettings || 9999
    );
    
    console.log(`Secure max attempts check: Assessment has ${assessmentData.attempts} attempts. ` + 
      `Max allowed attempts: ${secureMaxAttempts} ` + 
      `(Assessment value: ${assessmentData.maxAttempts}, Course settings value: ${maxAttemptsFromSettings})`);

    // Check if the student has exceeded the max attempts
    if (assessmentData.attempts >= secureMaxAttempts) {
      console.log(`Security check: Student has exceeded verified max attempts (${assessmentData.attempts}/${secureMaxAttempts})`);
      return {
        success: false,
        error: 'Maximum attempts exceeded',
        attemptsRemaining: 0
      };
    }

    // Get the secure data
    const secureRef = getDatabaseRef('secureAssessment', params.courseId, params.assessmentId, params.studentKey);
    const secureSnapshot = await secureRef.once('value');
    const secureData = secureSnapshot.val();

    if (!secureData || !secureData.correctOptionId) {
      throw new Error('Secure assessment data not found');
    }

    // Reconstruct the complete question for evaluation
    const completeQuestion = {
      questionText: assessmentData.questionText,
      options: assessmentData.options.map(opt => ({
        id: opt.id,
        text: opt.text,
        feedback: secureData.optionFeedback ? secureData.optionFeedback[opt.id] : ""
      })),
      correctOptionId: secureData.correctOptionId,
      explanation: secureData.explanation
    };

    // Evaluate the answer
    const result = evaluateAIQuestionAnswer(completeQuestion, params.answer);

    // Increment the attempts counter 
    let updatedAttempts = (assessmentData.attempts || 0) + 1;
    console.log(`Incrementing attempts from ${assessmentData.attempts || 0} to ${updatedAttempts} on answer submission`);
    
    // Use secure maxAttempts value from earlier validation
    const attemptsRemaining = secureMaxAttempts - updatedAttempts;

    // Create comprehensive submission record for Cloud Storage
    const submissionRecord = createMultipleChoiceSubmissionRecord(
      params,
      assessmentData,
      result,
      updatedAttempts
    );

    // Store detailed submission in Cloud Storage
    let submissionPath = null;
    try {
      submissionPath = await storeSubmission(submissionRecord);
    } catch (storageError) {
      console.warn(`âš ï¸ Failed to store submission in Cloud Storage: ${storageError.message}`);
      // Continue with assessment - storage failure shouldn't block student progress
    }

    // Check if this question was previously marked correct overall
    const wasCorrectOverall = assessmentData.correctOverall || false;

    // Update assessment data in the database (minimal data, just tracking)
    const updates = {
      attempts: updatedAttempts,
      status: result.isCorrect ? 'completed' : (attemptsRemaining > 0 ? 'attempted' : 'failed'),
      // Track whether the question has ever been answered correctly
      correctOverall: wasCorrectOverall || result.isCorrect,
      lastSubmission: {
        timestamp: getServerTimestamp(),
        answer: params.answer,
        isCorrect: result.isCorrect,
        feedback: result.feedback,
        correctOptionId: result.correctOptionId,
        submissionPath: submissionPath // Reference to Cloud Storage file
      }
    };

    // Update the assessment
    await assessmentRef.update(updates);

    // Update the grade if the answer is correct AND we haven't previously recorded a correct grade
    if (result.isCorrect && !wasCorrectOverall) {
      const gradeRef = getDatabaseRef('studentGrade', params.studentKey, params.courseId, params.assessmentId, params.isStaff);

      // Calculate score based on the pointsValue from settings
      const pointsValue = assessmentData.pointsValue || 2;

      // No penalty for attempts - full points for getting it correct
      const finalScore = pointsValue;

      await gradeRef.set(finalScore);
    }

    // Clean up secure data if assessment is completed or all attempts exhausted
    if (result.isCorrect || attemptsRemaining <= 0) {
      try {
        await secureRef.remove();
        console.log(`ðŸ—‘ï¸ Cleaned up secure assessment data for ${result.isCorrect ? 'completed' : 'failed'} assessment: ${params.assessmentId}`);
      } catch (cleanupError) {
        console.warn(`âš ï¸ Failed to cleanup secure data for ${params.assessmentId}:`, cleanupError.message);
        // Don't throw error - cleanup failure shouldn't affect the assessment result
      }
    }

    return {
      success: true,
      result: result,
      attemptsRemaining: attemptsRemaining,
      attemptsMade: updatedAttempts
    };
  }
}

/**
 * Factory function to create an AI Multiple Choice assessment handler
 * @param {Object} courseConfig - Course-specific configuration
 * @returns {Function} Cloud function handler
 */
function createAIMultipleChoice(courseConfig = {}) {
  return onCall({
    region: courseConfig.region || 'us-central1',
    timeoutSeconds: courseConfig.timeout || 60,
    memory: courseConfig.memory || '512MiB',
    enforceAppCheck: false,
  }, async (request) => {
    const data = request.data;
    const context = request;
    // Extract and validate parameters
    const params = extractParameters(data, context);
    
    // Create core handler instance
    const coreHandler = new AIMultipleChoiceCore(courseConfig);

    // Handle question generation operation
    if (params.operation === 'generate') {
      try {
        return await coreHandler.handleGenerate(params);
      } catch (error) {
        console.error("Error generating AI question:", error);
        throw new Error('Error generating question: ' + error.message);
      }
    }
    // Handle answer evaluation operation
    else if (params.operation === 'evaluate') {
      try {
        return await coreHandler.handleEvaluate(params);
      } catch (error) {
        console.error("Error evaluating answer:", error);
        throw new Error('Error evaluating answer: ' + error.message);
      }
    }

    // If the operation is neither generate nor evaluate
    throw new Error('Invalid operation. Supported operations are "generate" and "evaluate".');
  });
}

module.exports = {
  createAIMultipleChoice,
  AIMultipleChoiceCore
};